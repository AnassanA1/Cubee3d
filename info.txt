draw pixels :

                image is 5 pixels wide :

                                            (0,0) (1,0) (2,0) (3,0) (4,0)

                                            (0,1) (1,1) (2,1) (3,1) (4,1)

                                            (0,2) (1,2) (2,2) (3,2) (4,2)
                                        
                in memory its like this :  (indexes)

                        0 1 2 3 4 5 6 7 8 9 10 11 ...
                        0 1 2 3 4 5 6 7 8 9 10 11 ...
                        0 1 2 3 4 5 6 7 8 9 10 11 ...

                step one : how to find the right position pixel in the screen ?

                            pixel_number = y * width + x

                step two : convert pixel index to bytes index why ??
                            - because mlx pixel buffer wants 4 separate bytes
                                [ R | G | B | A ]

                            How is a color stored in an integer ?
                        When you use a color like: 0xRRGGBB
                            It looks like this in bytes (each box = 8 bits) color = 0xRRGGBB
                            ╔════╦════╦════╗
                            ║ RR ║ GG ║ BB ║   ← 3 bytes = 24 bits
                            ╚════╩════╩════╝

                            RR GG BB
                            ↑  ↑  ↑
                            8b 8b 8b  → total 24 bits

                So:

                Blue → rightmost 8 bits → no shift

                Green → in the middle → shift 8 bits

                Red → on the far left → shift 16 bits

                example : to get the red componements we shift by 16 becomes 0x0000AA  
                            - then we compare with 0xFF = 11111111 in binary
                    
                00000000 00000000 00000000 10101010   (value)
                00000000 00000000 00000000 11111111   (0xFF)
                -----------------------------------
                00000000 00000000 00000000 10101010   (result)

                Only the last 8 bits (AA) survive 

                

raycasting :

                - each ray --->  - what it hits .
                                - how far away it (can determine wall height)
                                - where in the wall (texture).

the player representation in the map :

                    - the player needs 3 things : - position in the map (x, y)
                                                - direction vector (the direction the player looking at (dirx, diry))
                                                - camera plane (simply camera screen defines the FOV 0,66 for human view)

                
                    Top of FOV ↑
                                |
                You are here → ● → Looking this way.        note : the plane is always perpendicular to the player
                                |                                               direction looking.
                Bottom of FOV ↓


                                    visual example:
                                    
                                    Facing EAST (→):
                                    Direction = (1, 0) pointing right →
                                    Plane = (0, 0.66) pointing up/down ↕
                                    
                                            ↑ (0, 0.66)
                                            |
                                        ←───●───→ (1, 0)
                                            |
                                            ↓


lets cast some rays baby :

    - to cast some rays we need to defines this formula : 
                            rayDirX = playerDirX + planeX * camera_x
                            rayDirY = playerDirY + planeY * camera_x

    - camera x ?? yeah since we casting rays from left to right 
        camera_x = 2 * x / screenWidth - 1
    
                    camerax.leftside = -1
                    camera.middleside = 0
                    camera.rightside = 1
    
    
    - after knowing the direction of the ray we will initialize the dda:

- What it does: Prepares the DDA algorithm by calculating:

        delta_dist: How far the ray travels to cross one grid square
        side_dist: Distance from current position to next grid line

- thank to this lodev.org :: --> deltaDistX = abs(1 / rayDirX)
                               deltaDistY = abs(1 / rayDirY)
            
calculating Side Distance
you need to figure out: "How far until my ray hits the next grid line?"

    -   This depends on which direction the ray is going
If rayDirX < 0:  (ray going LEFT ←)
    stepX = -1
    sideDistX = (posX - mapX) * deltaDistX
    
If rayDirX > 0:  (ray going RIGHT →)
    stepX = 1
    sideDistX = (mapX + 1.0 - posX) * deltaDistX

why ?? right ??...
- If going left, you need to reach the left edge of your current square: mapX
- If going right, you need to reach the right edge: mapX + 1.0
- Multiply by deltaDistX to convert from map units to ray travel distance

imagine : mapX=2      mapX=3
      ↓           ↓
  ----+----------+----
      |          |
      |   ●---→  |      Player at (2.3, 3.7)
      |  (ray)   |      Ray going RIGHT
  ----+----------+----
      ↑
    mapX+1 = 3.0

Distance to next vertical line = 3.0 - 2.3 = 0.7 map units
sideDistX = 0.7 * deltaDistX

The DDA Loop --> 
    while (hit == 0)
{
    if (sideDistX < sideDistY)  // Next vertical line is closer
    {
        sideDistX += deltaDistX;  // Move to next vertical line
        mapX += stepX;            // Update map position
        side = 0;                 // Hit vertical wall
    }
    else                         // Next horizontal line is closer
    {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;                 // Hit horizontal wall
    }
    
    if (map[mapX][mapY] == '1')  // Check if we hit a wall
        hit = 1;
}


After the DDA loop hits a wall
you need to calculate how far away that wall is to determine its height on screen.

thats how we determine the perpenducular distance ..... why right ..?
- You cannot use the actual ray length because it creates a fisheye effect

                                    Screen
                                            |
                                            |
                                    ray1    |  ray2
                                        \   |     /
                                        \   |    /
                                        \   |   /
                                        \   |  /
                                            ●  Player
                    
ray1 and ray2 travel different distances
If you use actual distance, walls look curved (fisheye!)
Solution: Use perpendicular distance to camera plane


** first to calculate it we need to determine if it horizental or vertical thats why i gave a flag 
- to wall->side = 0; // mark as vertical line |
- wall->side = 1; // mark as horizental line --

if(side == 0) perpWallDist = (sideDistX - deltaDistX);
else          perpWallDist = (sideDistY - deltaDistY);

after we are done calulating the perpenducular distance we will need to draw the fucking wall.
- this is never ending we are just getting started ...








